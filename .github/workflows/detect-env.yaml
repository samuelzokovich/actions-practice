name: Dynamic Deployment Configuration Pipeline

on:
  workflow_dispatch:
    inputs:
      environments:
        description: 'Comma-separated list of environments'
        required: true
        type: string
      services:
        description: 'Comma-separated list of services'
        required: true
        type: string

jobs:
  job1:
    runs-on: ubuntu-latest
    outputs:
      deployment_config: ${{ steps.update-config.outputs.deployment_config }}
    steps:
      - name: Initialize empty deployment config
        id: init-config
        run: |
          # Initialize an empty JSON array
          echo "deployment_config=[]" >> $GITHUB_ENV

      - name: Update deployment config with inputs
        id: update-config
        run: |
          # Fetch the comma-separated inputs
          environments="${{ github.event.inputs.environments }}"
          services="${{ github.event.inputs.services }}"

          # Split inputs into arrays
          IFS=',' read -r -a env_array <<< "$environments"
          IFS=',' read -r -a service_array <<< "$services"

          # Check if the number of environments matches the number of services
          if [ ${#env_array[@]} -ne ${#service_array[@]} ]; then
            echo "Error: The number of environments and services must match."
            exit 1
          fi

          # Initialize the config JSON array
          deployment_config="[]"

          # Loop through the arrays and build the deployment config JSON
          for i in "${!env_array[@]}"; do
            new_entry=$(jq -n --arg env "${env_array[$i]}" --arg svc "${service_array[$i]}" '{
              "environment": {
                "name": $env,
                "services": $svc,
                "metadata": {
                  "SX_PROJECT": "auto-generated-project",
                  "GEOGRAPHY": "auto-generated-geography",
                  "STAGE": "auto-generated-stage"
                }
              }
            }')
            deployment_config=$(echo $deployment_config | jq ". + [$new_entry]")
          done

          # Output the updated deployment config for the next job
          echo "Updated deployment config: $deployment_config"
          echo "deployment_config=$deployment_config" >> $GITHUB_ENV
          echo "deployment_config=$deployment_config" >> $GITHUB_OUTPUT

  job2:
    needs: job1
    runs-on: ubuntu-latest
    strategy:
      matrix:
        config_entry: ${{ fromJson(needs.job1.outputs.deployment_config) }}
    steps:
      - name: Process deployment config entry
        run: |
          # Access the current config entry for this iteration
          config_entry=${{ toJson(matrix.config_entry) }}
          echo "Processing deployment for: $config_entry"

          # Extract and use specific values from the JSON object
          environment_name=$(echo "${{ toJson(matrix.config_entry) }}" | jq -r '.environment.name')
          services=$(echo "${{ toJson(matrix.config_entry) }}" | jq -r '.environment.services')

          # Here you can run deployment tasks based on the extracted values
          echo "Deploying to environment: $environment_name"
          echo "Services: $services"
          # Add your actual deployment logic here
